# 演讲稿 — Polar + CRC-16 纠错编解码系统

---

## Page 1 — 封面

大家好，我们是 Team 4。今天要介绍的是我们为 EE3220 课程设计的 Polar + CRC-16 纠错编解码系统。

这个项目的核心目标是：在有噪声的通信信道上，实现可靠的数据传输。整体流程如 slide 下方的框图所示——24-bit 原始数据经过编码器生成 64-bit 码字，通过信道传输后，解码器负责纠错并还原数据。系统的关键参数是：码长 N=64，信息位 K=40，最小汉明距离 d_min=8，最多可纠正 3 位错误。

---

## Page 2 — 文件结构与共用参数包

在讲编解码流程之前，先介绍代码的整体结构。

我们的核心设计围绕一个共用参数包 `polar_common_pkg.sv`，它被编码器、解码器和测试平台三个模块共同引用。这样做的好处是保证编解码双方使用完全一致的参数定义，避免不一致导致的错误。

这个 package 定义了三类内容：

第一，基本参数——码长 N=64，信息位 K=40（其中 24 位是原始数据，16 位是 CRC 校验码），冻结位 F=24。

第二，位置映射表。如 slide 中的 64 格可视化图所示，蓝色的 40 个位置是信息位（INFO_POS），灰色的 24 个位置是冻结位（FROZEN_POS）。这些位置的选择依据是 Bhattacharyya 参数排序，且要求 popcount 不超过 3，以此保证最小距离 d_min=8。

第三，三个共用函数：`crc16_ccitt24` 计算 CRC-16 校验码；`build_u` 将数据和 CRC 映射到 u 向量的正确位置；`polar_transform64` 执行 Polar 蝶形变换。这三个函数编码器和解码器都会用到。

---

## Page 3 — 编码流程 Step 1：CRC-16 计算

现在进入编码器的工作流程。第一步是 CRC-16 计算。

我们采用的是 CRC-16-CCITT 标准，生成多项式为 x^16 + x^12 + x^5 + 1，对应的异或常量是 0x1021。

如左侧的代码所示，算法的核心是一个 16 位线性反馈移位寄存器。初始值为 0，从最高位 bit 23 开始逐位处理。每一步先计算反馈位——当前数据位与 CRC 最高位异或；然后 CRC 左移一位；如果反馈位为 1，就与多项式常量 0x1021 做异或。

右侧的 LFSR 结构图展示了这个移位寄存器的硬件对应关系。经过 24 次迭代后，寄存器中的值就是我们需要的 16 位 CRC 校验码。

以测试用例为例，输入 data_in = 24'hABCDEF，经过这个函数计算就得到对应的 CRC-16 值。

---

## Page 4 — 编码流程 Step 2-3：构建 u 向量与 Polar 变换

第二步是构建 64 位的 u 向量。

如 slide 上方所示，u 向量由三部分组成：24 位原始数据放入 INFO_POS 的前 24 个位置，16 位 CRC 放入 INFO_POS 的后 16 个位置，而 24 个冻结位全部置零。

这里需要特别注意位序的映射关系：数据是按 `data[23-k]` 映射到 `u[INFO_POS[k]]`，CRC 是按 `crc[15-k]` 映射到 `u[INFO_POS[24+k]]`。这个反向映射是一个容易出错的地方。

第三步是 Polar 蝶形变换。slide 中间展示了 N=8 时的蝶形网络结构作为示意。实际 N=64 时是 6 级蝶形运算，每级包含 32 个 XOR 操作。算法的核心公式是 `v[i+j+half] ^= v[i+j]`。

这个变换有一个关键性质：它是自逆的，即 F_N 等于 F_N 的逆，在 GF(2) 域上成立。这意味着解码器可以复用同一个变换函数做逆变换。

slide 底部展示了编码器的组合逻辑链：data_reg 经过 CRC 计算、build_u、Polar 变换，最终得到 codeword。这三步全部在 `always_comb` 块中完成，是纯组合逻辑。

---

## Page 5 — 编码器流水线与时序

接下来看编码器的流水线设计。

如上方的时序图所示，编码器采用三级流水线结构。Cycle 0 时 start 脉冲到来，data_in 被锁存到 data_reg；Cycle 1 时 pipe0 信号传递，组合逻辑在这个阶段完成全部计算；Cycle 2 时 pipe1 和 done 同时拉高，codeword 输出有效。

下方的流水线架构图更清晰地展示了这个结构：Stage 0 是输入寄存器，Stage 1 是纯组合逻辑（CRC、build_u、Polar 变换），Stage 2 是输出寄存器。寄存器边界由时钟上升沿触发。

关键要求是：done 信号必须在 start 后恰好第 2 个时钟沿拉高，持续一个周期后自动回零。这是一个严格的接口时序约束。

---

## Page 6 — 解码流程 Step 1-2：逆变换与 Syndrome 提取

现在进入解码器的工作流程。

第一步是逆 Polar 变换。解码器接收到可能被噪声翻转的 64 位 rx，对其调用同一个 `polar_transform64` 函数，得到 u_hat。由于变换的自逆性质，如果没有错误，u_hat 就等于原始的 u 向量。

右侧的对比图展示了有错误时的情况：原始 u 的冻结位全为 0，但 u_hat 的冻结位可能出现非零值。这些非零的冻结位就是错误的"指纹"。

第二步是 Syndrome 提取。代码很简洁：遍历 24 个冻结位位置，将 u_hat 在这些位置的值提取出来，组成 24 位的 syndrome 向量。

如果 syndrome 全为零，说明没有检测到错误；如果 syndrome 不为零，说明存在传输错误，需要进入纠错阶段。

---

## Page 7 — 解码流程 Step 3：有界距离纠错

第三步是核心的纠错逻辑——基于列 syndrome 查找表的有界距离解码。

如左侧的决策流程图所示，纠错按错误重量从小到大逐级搜索：

首先检查 syndrome 是否为零。如果是，不需要纠错。

如果不为零，先做 Weight-1 搜索：在 64 个 COL_SYN 表项中，查找是否有某个 `COL_SYN[j]` 等于 syndrome。如果找到，说明只有第 j 位出错。

如果 Weight-1 没找到，做 Weight-2 搜索：查找是否有两个表项异或后等于 syndrome，需要比较约 2000 次。

如果还没找到，做 Weight-3 搜索：三个表项异或匹配，约 41000 次比较。

如果三级搜索都没有匹配，说明错误超出纠正能力，直接输出 valid=0 拒绝。

右侧展示了 COL_SYN 查找表的部分内容。每个表项是将单位错误向量经过 Polar 变换后投影到冻结位位置得到的 24 位签名。关键性质是：64 个表项全部唯一，这保证了 3 位以内的错误都能被唯一识别。

---

## Page 8 — 解码流程 Step 4-5：纠错应用与 CRC 校验

第四步是应用纠错。将接收到的 rx 与错误模式 err_pat 做异或，得到纠正后的码字；再做一次 Polar 变换得到 u_final；然后强制所有冻结位为零。

接着从 u_final 中提取 24 位数据和 16 位 CRC。这里同样要注意位序：数据提取用 `data_out[23-k] = u_final[INFO_POS[k]]`，CRC 提取用 `crc_rx[15-k] = u_final[INFO_POS[24+k]]`。

第五步是 CRC 校验——这是最后一道安全防线。用提取出的 data_out 重新计算一次 CRC，与提取的 crc_rx 对比。只有当纠错标记 correctable 为真，且 CRC 校验通过，valid 才输出 1。

如 slide 底部的安全提示所强调的：这是双重保护机制。即使 syndrome 匹配成功找到了错误模式，CRC 还会做二次验证。这可以捕获极少数 syndrome 误匹配的情况，确保不会输出错误数据。

---

## Page 9 — 解码器流水线与时序

解码器的流水线结构与编码器完全对称，同样是三级流水线。

时序图显示：start 到来时锁存 rx 到 rx_reg，经过 pipe0、pipe1 两级延迟后，done 在第 2 个周期拉高，同时输出 data_out 和 valid。

中间的组合逻辑阶段需要完成：逆变换、syndrome 提取、三级错误搜索、纠错、数据提取和 CRC 校验。虽然组合逻辑的复杂度远高于编码器（O(N^3) vs O(N)），但在仿真环境中仍可在单个时钟周期内完成。

底部的对比表清晰地展示了编码器和解码器的异同：两者的流水线结构相同，done 延迟都是 2 个周期（规范允许解码器最多 12 周期），但组合逻辑的复杂度差异显著。

---

## Page 10 — 验证结果与总结

最后是验证结果。

左侧的表格展示了 tb_basic 烟雾测试的全部测试用例和结果：

- Case A：无错传输，解码器正确输出 valid=1 和原始数据，通过。
- Case B：分别注入 1 位、2 位、3 位错误，解码器全部成功纠正，通过。
- Case C：注入 4 位错误，解码器正确拒绝输出 valid=0，通过。
- Fail-safe：注入 5 位错误，解码器同样拒绝，通过。

烟雾测试得分 30/30，全部通过。

右侧总结了系统的关键设计特点：共用参数包保证编解码一致性；CRC-16 提供第二层错误检测；列 syndrome 查找表实现唯一错误定位；以及贯穿整个设计的安全优先原则——宁可拒绝，不输出错误数据。

以上就是我们的系统设计介绍，谢谢。
