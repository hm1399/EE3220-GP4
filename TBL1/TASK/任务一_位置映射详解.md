# 任务一：信息位与冻结位的位置映射 — 简单易懂详解

## 一、先搞懂问题：我们在干什么？

把 64 个位置（编号 0~63）分成两组：

```
64 个位置
├── 40 个信息位位置（INFO_POS）：用来放真正的数据（24位）和 CRC（16位）
└── 24 个冻结位位置（FROZEN_POS）：永远填 0，起纠错保护作用
```

**类比**：想象一个 64 格的书架，你要选 40 格放书（有用信息），剩下 24 格留空（冻结位=0）。选哪些格子放书，直接决定了系统抗干扰的能力。

---

## 二、为什么位置选择很重要？

Polar 编码后，每个位置对码字的"贡献"不同。有些位置翻转后影响很多输出位（保护力强），有些只影响很少（保护力弱）。

**关键概念：行重量（row weight）**

每个位置 i 在编码矩阵中对应一行，这一行有多少个 1，就叫"行重量"。行重量越大，纠错能力越强。

**规律非常简单**：位置 i 的行重量 = `2^(6 - popcount(i))`

其中 `popcount(i)` = i 的二进制表示中 1 的个数。

### 举例

| 位置（十进制） | 二进制 | 1 的个数 | 行重量 |
| --- | --- | --- | --- |
| 0 | 000000 | 0 | 2^6 = 64 |
| 1 | 000001 | 1 | 2^5 = 32 |
| 3 | 000011 | 2 | 2^4 = 16 |
| 7 | 000111 | 3 | 2^3 = 8 |
| 15 | 001111 | 4 | 2^2 = 4 |
| 31 | 011111 | 5 | 2^1 = 2 |
| 63 | 111111 | 6 | 2^0 = 1 |

---

## 三、dmin = 8 的约束意味着什么？

项目要求最小汉明距离 dmin = 8，意思是：**所有信息位的行重量都必须 >= 8**。

由上面的公式：

```
行重量 >= 8
=> 2^(6 - popcount) >= 2^3
=> 6 - popcount >= 3
=> popcount <= 3
```

**结论：只能选二进制中 1 的个数 <= 3 的位置作为信息位。**

---

## 四、有多少位置满足条件？

| 1 的个数（popcount） | 位置数量 | 行重量 |
| --- | --- | --- |
| 0 | C(6,0) = 1 | 64 |
| 1 | C(6,1) = 6 | 32 |
| 2 | C(6,2) = 15 | 16 |
| 3 | C(6,3) = 20 | 8 |
| **合计** | **42** | **>= 8** |

满足条件的有 **42 个位置**，但我们只需要 **40 个信息位**，所以要从这 42 个中**剔除 2 个最差的**。

剩下的位置（popcount = 4, 5, 6 共 22 个）行重量太低（4, 2, 1），全部作为冻结位。再加上从 42 个里剔除的 2 个，刚好凑成 24 个冻结位。

---

## 五、怎么决定剔除哪 2 个？—— 信道可靠性排序

不是所有 popcount <= 3 的位置都同样"好"。Polar 码理论告诉我们，每个子信道有不同的**可靠性**（reliability）。可靠性越高，传输越不容易出错，越适合放信息位。

我们用 **Bhattacharyya 参数** 来衡量可靠性：

- Z 值越小 → 信道越可靠 → 越适合做信息位
- Z 值越大 → 信道越不可靠 → 应该做冻结位

---

## 六、手把手教你算：Python 脚本

下面这段 Python 代码会帮你：
1. 计算每个位置的可靠性（Bhattacharyya 参数）
2. 筛选出 popcount <= 3 的位置（保证 dmin=8）
3. 从中选出最可靠的 40 个作为 INFO_POS
4. 其余 24 个作为 FROZEN_POS

```python
def compute_polar_positions():
    N = 64
    n = 6
    K = 40

    # ========== 第1步：计算 Bhattacharyya 参数 ==========
    # 使用 BEC(0.5) 信道模型，得到通用可靠性排序
    z = [0.5]  # 初始值
    for stage in range(n):
        new_z = []
        for val in z:
            new_z.append(2 * val - val * val)  # 较差信道（minus）
            new_z.append(val * val)             # 较好信道（plus）
        z = new_z
    # z[i] 就是位置 i 的 Bhattacharyya 参数，越小越可靠

    # ========== 第2步：筛选 popcount <= 3 的位置 ==========
    eligible = []
    for i in range(N):
        if bin(i).count('1') <= 3:
            eligible.append(i)
    print(f"满足 dmin=8 的候选位置数量: {len(eligible)}")
    # 应该是 42

    # ========== 第3步：按可靠性排序，选最好的 40 个 ==========
    # z 值越小越可靠，所以按 z 值升序排列
    eligible_sorted = sorted(eligible, key=lambda i: z[i])
    info_pos = sorted(eligible_sorted[:K])    # 取前40个最可靠的
    frozen_pos = sorted(set(range(N)) - set(info_pos))  # 剩下24个

    # ========== 第4步：输出结果 ==========
    print(f"\nINFO_POS ({len(info_pos)} 个):")
    print(info_pos)
    print(f"\nFROZEN_POS ({len(frozen_pos)} 个):")
    print(frozen_pos)

    # 被剔除的2个（popcount<=3 但没被选中）
    excluded = sorted(set(eligible) - set(info_pos))
    print(f"\n从候选中剔除的位置: {excluded}")
    for e in excluded:
        print(f"  位置 {e}: 二进制={bin(e)[2:].zfill(6)}, popcount={bin(e).count('1')}, Z={z[e]:.10f}")

    # 验证 dmin
    min_weight = min(2 ** (6 - bin(i).count('1')) for i in info_pos)
    print(f"\n最小行重量 (dmin) = {min_weight}")

    # 输出 SystemVerilog 格式
    print("\n// ========== 复制到 SystemVerilog 代码中 ==========")
    info_str = ", ".join(str(x) for x in info_pos)
    frozen_str = ", ".join(str(x) for x in frozen_pos)
    print(f"localparam int INFO_POS [0:{K-1}] = '{{{info_str}}};")
    print(f"localparam int FROZEN_POS [0:{N-K-1}] = '{{{frozen_str}}};")

compute_polar_positions()
```

---

## 七、运行结果（参考答案）

运行上面的脚本，会得到类似如下结果：

```
满足 dmin=8 的候选位置数量: 42

被剔除的 2 个位置: [0, 1]
  位置 0: 二进制=000000, popcount=0, Z 值最大（最不可靠）
  位置 1: 二进制=000001, popcount=1, Z 值次大

最小行重量 (dmin) = 8
```

**直觉理解**：位置 0 虽然行重量最大（64），但它是所有输入异或在一起的结果，对噪声最敏感，所以可靠性最差。这是 Polar 码的一个反直觉特性。

---

## 八、把结果写进代码

在你的 `polar_common_pkg.sv`（共用参数包）中定义：

```systemverilog
package polar_common_pkg;

    localparam int N = 64;
    localparam int K = 40;

    // 运行 Python 脚本后，将输出的数组复制到这里
    // 下面是示例（以实际脚本输出为准）：
    localparam int INFO_POS [0:39] = '{
        // ... 40 个信息位位置 ...
    };

    localparam int FROZEN_POS [0:23] = '{
        // ... 24 个冻结位位置 ...
    };

endpackage
```

编码器和解码器都 `import polar_common_pkg::*;` 来使用这些位置。

---

## 九、自检清单

完成任务一后，确认以下几点：

- [ ] INFO_POS 恰好有 40 个元素，FROZEN_POS 恰好有 24 个元素
- [ ] INFO_POS 和 FROZEN_POS 没有重叠，合起来恰好是 0~63
- [ ] INFO_POS 中所有位置的 popcount <= 3（保证 dmin=8）
- [ ] Python 脚本已运行并验证 dmin = 8
- [ ] 结果已写入 SystemVerilog 参数包

---

## 十、总结

```
选位置的核心逻辑：

1. 每个位置的"保护力" = 2^(6 - 该位置二进制中1的个数)
2. 要求保护力 >= 8，所以只选1的个数 <= 3 的位置（共42个）
3. 42个里挑40个最可靠的 → INFO_POS
4. 剩下24个 → FROZEN_POS（永远填0）
```
