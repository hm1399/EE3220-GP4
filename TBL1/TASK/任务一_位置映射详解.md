# 任务一：信息位与冻结位的位置映射 — 详解

## 一、先搞懂问题：我们在干什么？

把 64 个位置（编号 0~63）分成两组：

```
64 个位置
├── 40 个信息位位置（INFO_POS）：用来放真正的数据（24位）和 CRC（16位）
└── 24 个冻结位位置（FROZEN_POS）：永远填 0，起纠错保护作用
```

**类比**：想象一个 64 格的书架，你要选 40 格放书（有用信息），剩下 24 格留空（冻结位=0）。选哪些格子放书，直接决定了系统抗干扰的能力。

---

## 二、为什么位置选择很重要？

Polar 编码后，每个位置对码字的"贡献"不同。有些位置翻转后影响很多输出位（保护力强），有些只影响很少（保护力弱）。

**关键概念：行重量（row weight）**

每个位置 i 在编码矩阵中对应一行，这一行有多少个 1，就叫"行重量"。行重量越大，纠错能力越强。

**规律**：位置 i 的行重量 = `2^(6 - popcount(i))`

其中 `popcount(i)` = i 的二进制表示中 1 的个数。

### 举例

| 位置（十进制） | 二进制 | 1 的个数 | 行重量 |
| --- | --- | --- | --- |
| 0 | 000000 | 0 | 2^6 = 64 |
| 1 | 000001 | 1 | 2^5 = 32 |
| 3 | 000011 | 2 | 2^4 = 16 |
| 7 | 000111 | 3 | 2^3 = 8 |
| 15 | 001111 | 4 | 2^2 = 4 |
| 31 | 011111 | 5 | 2^1 = 2 |
| 63 | 111111 | 6 | 2^0 = 1 |

### 为什么行重量决定 dmin？

Polar 编码本质上是矩阵乘法 `codeword = u × G`（GF(2) 上）。当 u 向量只有一个信息位为 1、其余为 0 时，输出码字就是 G 矩阵中对应行。这个码字与全 0 码字的汉明距离 = 该行中 1 的个数 = 行重量。

所以 **最小汉明距离 dmin = 所有信息位位置中的最小行重量**。

---

## 三、dmin = 8 的约束意味着什么？

项目要求最小汉明距离 dmin = 8，意思是：**所有信息位的行重量都必须 >= 8**。

由上面的公式：

```
行重量 >= 8
=> 2^(6 - popcount) >= 2^3
=> 6 - popcount >= 3
=> popcount <= 3
```

**结论：只能选二进制中 1 的个数 <= 3 的位置作为信息位。**

dmin = 8 带来的纠错能力：
- **纠正** 1~3 位翻转（因为 floor((8-1)/2) = 3）
- **检测** 4 位翻转（距离不够纠正，但能发现错误，输出 valid=0）

---

## 四、有多少位置满足条件？

| 1 的个数（popcount） | 位置数量 | 行重量 |
| --- | --- | --- |
| 0 | C(6,0) = 1 | 64 |
| 1 | C(6,1) = 6 | 32 |
| 2 | C(6,2) = 15 | 16 |
| 3 | C(6,3) = 20 | 8 |
| **合计** | **42** | **>= 8** |

满足条件的有 **42 个位置**，但我们只需要 **40 个信息位**，所以要从这 42 个中**剔除 2 个最差的**。

剩下的位置（popcount = 4, 5, 6 共 22 个）行重量太低（4, 2, 1），全部作为冻结位。再加上从 42 个里剔除的 2 个，刚好凑成 24 个冻结位。

---

## 五、怎么决定剔除哪 2 个？—— 信道可靠性排序

不是所有 popcount <= 3 的位置都同样"好"。Polar 码理论告诉我们，每个子信道有不同的**可靠性**（reliability）。可靠性越高，传输越不容易出错，越适合放信息位。

我们用 **Bhattacharyya 参数 Z(i)** 来衡量可靠性：

- Z 值越小 → 信道越可靠 → 越适合做信息位
- Z 值越大 → 信道越不可靠 → 应该做冻结位

### Bhattacharyya 参数的计算方法（BEC(0.5) 模型）

Polar 码的信道极化过程可以用递推公式描述。对于二进制删除信道 BEC(ε)，初始 Z = ε = 0.5，然后经过 6 级极化（因为 N = 2^6 = 64）：

```
初始：z = [0.5]

每一级极化，每个 z 值分裂成两个：
  较差子信道（minus）：z_new = 2z - z^2    （Z 值变大，可靠性变差）
  较好子信道（plus）： z_new = z^2         （Z 值变小，可靠性变好）

经过 6 级后，得到 64 个 Z 值，分别对应位置 0~63
```

经过 6 级极化后，大部分子信道要么 Z ≈ 1（完全不可靠），要么 Z ≈ 0（几乎完美）——这就是"信道极化"现象。

---

## 六、Python 脚本：计算位置映射

下面这段 Python 代码完成全部计算：

```python
def compute_polar_positions():
    N = 64
    n = 6
    K = 40

    # ========== 第1步：计算 Bhattacharyya 参数 ==========
    # 使用 BEC(0.5) 信道模型，得到通用可靠性排序
    z = [0.5]  # 初始值
    for stage in range(n):
        new_z = []
        for val in z:
            new_z.append(2 * val - val * val)  # 较差信道（minus）
            new_z.append(val * val)             # 较好信道（plus）
        z = new_z
    # z[i] 就是位置 i 的 Bhattacharyya 参数，越小越可靠

    # ========== 第2步：筛选 popcount <= 3 的位置 ==========
    eligible = []
    for i in range(N):
        if bin(i).count('1') <= 3:
            eligible.append(i)
    print(f"满足 dmin=8 的候选位置数量: {len(eligible)}")
    # 应该是 42

    # ========== 第3步：按可靠性排序，选最好的 40 个 ==========
    # z 值越小越可靠，所以按 z 值升序排列
    eligible_sorted = sorted(eligible, key=lambda i: z[i])
    info_pos = sorted(eligible_sorted[:K])    # 取前40个最可靠的
    frozen_pos = sorted(set(range(N)) - set(info_pos))  # 剩下24个

    # ========== 第4步：输出结果 ==========
    print(f"\nINFO_POS ({len(info_pos)} 个):")
    print(info_pos)
    print(f"\nFROZEN_POS ({len(frozen_pos)} 个):")
    print(frozen_pos)

    # 被剔除的2个（popcount<=3 但没被选中）
    excluded = sorted(set(eligible) - set(info_pos))
    print(f"\n从候选中剔除的位置: {excluded}")
    for e in excluded:
        print(f"  位置 {e}: 二进制={bin(e)[2:].zfill(6)}, "
              f"popcount={bin(e).count('1')}, Z={z[e]:.10f}")

    # 验证 dmin
    min_weight = min(2 ** (6 - bin(i).count('1')) for i in info_pos)
    print(f"\n最小行重量 (dmin) = {min_weight}")

    # 输出 SystemVerilog 格式
    print("\n// ========== 复制到 polar_common_pkg.sv ==========")
    info_str = ", ".join(str(x) for x in info_pos)
    frozen_str = ", ".join(str(x) for x in frozen_pos)
    print(f"localparam int INFO_POS [0:{K-1}] = '{{{info_str}}};")
    print(f"localparam int FROZEN_POS [0:{N-K-1}] = '{{{frozen_str}}};")

compute_polar_positions()
```

---

## 七、运行结果

### 被剔除的 2 个位置

| 位置 | 二进制 | popcount | Z 值 | 原因 |
| --- | --- | --- | --- | --- |
| 0 | 000000 | 0 | 1.0000000000 | Z=1，完全不可靠 |
| 1 | 000001 | 1 | 0.9999999995 | Z≈1，几乎完全不可靠 |

**直觉理解**：位置 0 虽然行重量最大（64），但它的 Bhattacharyya 参数 Z=1，意味着该子信道完全不可靠——传输的信息几乎必然丢失。位置 1 也类似（Z≈1）。这是 Polar 码的一个反直觉特性：行重量大 ≠ 子信道可靠。

### 最终结果

**INFO_POS（40 个信息位位置）：**

```
[2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 16, 17, 18, 19, 20, 21, 22,
 24, 25, 26, 28, 32, 33, 34, 35, 36, 37, 38, 40, 41, 42, 44, 48, 49, 50, 52, 56]
```

**FROZEN_POS（24 个冻结位位置）：**

```
[0, 1, 15, 23, 27, 29, 30, 31, 39, 43, 45, 46, 47, 51, 53, 54, 55, 57, 58, 59, 60, 61, 62, 63]
```

### 验证

- INFO_POS 有 40 个元素
- FROZEN_POS 有 24 个元素
- 两组无重叠，合起来恰好是 0~63
- INFO_POS 中所有位置 popcount <= 3
- **dmin = 8**

### 64 位置完整信息表

| 位置 | 二进制 | popcount | 行重量 | Z 值 | 类型 |
| --- | --- | --- | --- | --- | --- |
| 0 | 000000 | 0 | 64 | 1.0000 | FROZEN |
| 1 | 000001 | 1 | 32 | 1.0000 | FROZEN |
| 2 | 000010 | 1 | 32 | 1.0000 | INFO |
| 3 | 000011 | 2 | 16 | 0.9999 | INFO |
| 4 | 000100 | 1 | 32 | 1.0000 | INFO |
| 5 | 000101 | 2 | 16 | 0.9999 | INFO |
| 6 | 000110 | 2 | 16 | 0.9998 | INFO |
| 7 | 000111 | 3 | 8 | 0.9692 | INFO |
| 8 | 001000 | 1 | 32 | 1.0000 | INFO |
| 9 | 001001 | 2 | 16 | 0.9996 | INFO |
| 10 | 001010 | 2 | 16 | 0.9992 | INFO |
| 11 | 001011 | 3 | 8 | 0.9426 | INFO |
| 12 | 001100 | 2 | 16 | 0.9973 | INFO |
| 13 | 001101 | 3 | 8 | 0.8991 | INFO |
| 14 | 001110 | 3 | 8 | 0.8374 | INFO |
| **15** | **001111** | **4** | **4** | **0.3561** | **FROZEN** |
| 16 | 010000 | 1 | 32 | 1.0000 | INFO |
| 17 | 010001 | 2 | 16 | 0.9973 | INFO |
| 18 | 010010 | 2 | 16 | 0.9948 | INFO |
| 19 | 010011 | 3 | 8 | 0.8613 | INFO |
| 20 | 010100 | 2 | 16 | 0.9856 | INFO |
| 21 | 010101 | 3 | 8 | 0.7747 | INFO |
| 22 | 010110 | 3 | 8 | 0.6722 | INFO |
| **23** | **010111** | **4** | **4** | **0.1827** | **FROZEN** |
| 24 | 011000 | 2 | 16 | 0.9523 | INFO |
| 25 | 011001 | 3 | 8 | 0.6109 | INFO |
| 26 | 011010 | 3 | 8 | 0.4870 | INFO |
| **27** | **011011** | **4** | **4** | **0.0805** | **FROZEN** |
| 28 | 011100 | 3 | 8 | 0.3442 | INFO |
| **29** | **011101** | **4** | **4** | **0.0362** | **FROZEN** |
| **30** | **011110** | **4** | **4** | **0.0199** | **FROZEN** |
| **31** | **011111** | **5** | **2** | **0.0001** | **FROZEN** |
| 32 | 100000 | 1 | 32 | 0.9999 | INFO |
| 33 | 100001 | 2 | 16 | 0.9801 | INFO |
| 34 | 100010 | 2 | 16 | 0.9638 | INFO |
| 35 | 100011 | 3 | 8 | 0.6558 | INFO |
| 36 | 100100 | 2 | 16 | 0.9195 | INFO |
| 37 | 100101 | 3 | 8 | 0.5130 | INFO |
| 38 | 100110 | 3 | 8 | 0.3891 | INFO |
| **39** | **100111** | **4** | **4** | **0.0477** | **FROZEN** |
| 40 | 101000 | 2 | 16 | 0.8173 | INFO |
| 41 | 101001 | 3 | 8 | 0.3278 | INFO |
| 42 | 101010 | 3 | 8 | 0.2253 | INFO |
| **43** | **101011** | **4** | **4** | **0.0144** | **FROZEN** |
| 44 | 101100 | 3 | 8 | 0.1387 | INFO |
| **45** | **101101** | **4** | **4** | **0.0052** | **FROZEN** |
| **46** | **101110** | **4** | **4** | **0.0027** | **FROZEN** |
| **47** | **101111** | **5** | **2** | **0.0000** | **FROZEN** |
| 48 | 110000 | 2 | 16 | 0.6439 | INFO |
| 49 | 110001 | 3 | 8 | 0.1626 | INFO |
| 50 | 110010 | 3 | 8 | 0.1009 | INFO |
| **51** | **110011** | **4** | **4** | **0.0027** | **FROZEN** |
| 52 | 110100 | 3 | 8 | 0.0574 | INFO |
| **53** | **110101** | **4** | **4** | **0.0008** | **FROZEN** |
| **54** | **110110** | **4** | **4** | **0.0004** | **FROZEN** |
| **55** | **110111** | **5** | **2** | **0.0000** | **FROZEN** |
| 56 | 111000 | 3 | 8 | 0.0308 | INFO |
| **57** | **111001** | **4** | **4** | **0.0002** | **FROZEN** |
| **58** | **111010** | **4** | **4** | **0.0001** | **FROZEN** |
| **59** | **111011** | **5** | **2** | **0.0000** | **FROZEN** |
| **60** | **111100** | **4** | **4** | **0.0001** | **FROZEN** |
| **61** | **111101** | **5** | **2** | **0.0000** | **FROZEN** |
| **62** | **111110** | **5** | **2** | **0.0000** | **FROZEN** |
| **63** | **111111** | **6** | **1** | **0.0000** | **FROZEN** |

（加粗行为 FROZEN 位置。可以看到：popcount >= 4 的位置全部是 FROZEN，加上 popcount=0 的位置 0 和 popcount=1 的位置 1。）

---

## 八、把结果写进代码

创建 `polar_common_pkg.sv`（共用参数包），编码器和解码器都引用它：

```systemverilog
package polar_common_pkg;

    localparam int N = 64;       // 码字长度
    localparam int K = 40;       // 信息位数（24 数据 + 16 CRC）
    localparam int F = 24;       // 冻结位数

    // 40 个信息位位置（popcount <= 3，按 Bhattacharyya 排序后最可靠的 40 个）
    localparam int INFO_POS [0:39] = '{
        2,  3,  4,  5,  6,  7,  8,  9, 10, 11,
       12, 13, 14, 16, 17, 18, 19, 20, 21, 22,
       24, 25, 26, 28, 32, 33, 34, 35, 36, 37,
       38, 40, 41, 42, 44, 48, 49, 50, 52, 56
    };

    // 24 个冻结位位置（编码时置 0，解码时强制为 0）
    localparam int FROZEN_POS [0:23] = '{
        0,  1, 15, 23, 27, 29, 30, 31,
       39, 43, 45, 46, 47, 51, 53, 54,
       55, 57, 58, 59, 60, 61, 62, 63
    };

endpackage
```

在编码器和解码器中引用：

```systemverilog
import polar_common_pkg::*;
```

### 编码器中如何使用这些位置

```systemverilog
// 构造 u 向量
logic [63:0] u;

// 1. 所有位先清零（冻结位自动为 0）
u = 64'b0;

// 2. 前 24 个信息位位置放数据
for (int k = 0; k < 24; k++)
    u[INFO_POS[k]] = data_in[23 - k];   // 注意 23-k 的映射方向

// 3. 后 16 个信息位位置放 CRC
for (int k = 0; k < 16; k++)
    u[INFO_POS[24 + k]] = crc[15 - k];  // 注意 15-k 的映射方向
```

### 解码器中如何使用这些位置

```systemverilog
// 从 u_hat 中提取数据和 CRC
for (int k = 0; k < 24; k++)
    data_out[23 - k] = u_hat[INFO_POS[k]];

for (int k = 0; k < 16; k++)
    crc_rx[15 - k] = u_hat[INFO_POS[24 + k]];

// 强制冻结位为 0
for (int k = 0; k < 24; k++)
    u_hat[FROZEN_POS[k]] = 1'b0;
```

---

## 九、常见问题

### Q1: 为什么位置 0 的 Z 值 = 1，却有最大的行重量 64？

行重量和信道可靠性是两个不同的概念：
- **行重量**衡量的是"如果这个位成功传输，它能给码字贡献多少冗余"
- **Z 值**衡量的是"这个位能否被成功传输"

位置 0 对应所有 64 个输出位的异或，虽然冗余极高，但极化过程使得它极不可靠（Z=1），在接收端几乎无法正确判决。

### Q2: 能不能不用 Bhattacharyya 参数，直接把 42 个中随便去掉 2 个？

理论上只要 popcount <= 3 就满足 dmin=8，所以去掉任意 2 个都不会破坏 dmin。但选择最不可靠的 2 个（位置 0 和 1）来剔除是最优的——把最差的子信道冻结掉，解码性能最好。

### Q3: INFO_POS 的顺序重要吗？

是的。INFO_POS[0..23] 对应数据位，INFO_POS[24..39] 对应 CRC 位。这个顺序决定了数据和 CRC 在 u 向量中的放置方式。数组内部按位置编号升序排列。

---

## 十、自检清单

完成任务一后，确认以下几点：

- [ ] INFO_POS 恰好有 40 个元素，FROZEN_POS 恰好有 24 个元素
- [ ] INFO_POS 和 FROZEN_POS 没有重叠，合起来恰好是 0~63
- [ ] INFO_POS 中所有位置的 popcount <= 3（保证 dmin=8）
- [ ] Python 脚本已运行并验证 dmin = 8
- [ ] 结果已写入 `polar_common_pkg.sv`
- [ ] 编码器和解码器都 `import polar_common_pkg::*`

---

## 十一、总结

```
选位置的核心逻辑（3 步）：

1. 每个位置的"保护力"（行重量） = 2^(6 - 该位置二进制中1的个数)
   要求保护力 >= 8 → 只选 popcount <= 3 的位置 → 共 42 个候选

2. 用 Bhattacharyya 参数 (BEC(0.5)) 评估每个候选的信道可靠性
   Z 值越小 → 越可靠 → 越应该做信息位

3. 从 42 个候选中选最可靠的 40 个 → INFO_POS
   剩下 24 个（含 22 个 popcount>=4 的 + 被剔除的位置 0 和 1）→ FROZEN_POS
```

这一步完成后，`polar_common_pkg.sv` 就是整个项目的基础，后续的 CRC 模块、编码器、解码器都依赖它。
