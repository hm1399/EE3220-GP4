# EE3220 TBL1 项目：通俗易懂的完整指南

## 一句话概括

你要用硬件描述语言（SystemVerilog）做一个**"发送-接收"系统**：发送端把 24 位数据加密打包成 64 位发出去，接收端收到后能自动修复传输中被破坏的比特，还原出原始数据。

---

## 用生活例子理解整个项目

### 场景

你在地球通过无线电给火星上的机器人发指令。指令是一串 0 和 1（比如 24 位的二进制数据）。

**问题**：太空中有辐射、信号衰减，传输过程中某些 0 可能变成 1，或者 1 变成 0（叫"比特翻转"）。如果机器人收到错误指令还照做，后果很严重。

**解决方案**：在发送前给数据加上"保护壳"（冗余信息），这样即使传输中有少量错误，接收端也能自动修复。如果错误太多修不了，就直接拒绝（宁可不执行，也不执行错误指令）。

### 这个"保护壳"由两层构成

```text
第一层保护：CRC-16（校验码）
  - 类似快递单上的校验码
  - 对 24 位数据算出 16 位校验值，一起打包
  - 接收端重新算一遍，如果对不上就知道数据坏了

第二层保护：Polar 码（纠错码）
  - 类似把一句话重复说三遍，听错了也能猜对
  - 把 40 位（24 数据 + 16 CRC）扩展成 64 位
  - 多出的 24 位是冗余，用来纠错
  - 能修复 1~3 位错误，能检测 4 位错误
```

### 整个通信流程

```text
地球（发送端）                        太空信道                     火星（接收端）

24位数据
   │
   ▼
计算CRC-16 → 得到16位校验码
   │
   ▼
40位(24数据+16CRC)
   │
   ▼
Polar编码 → 扩展成64位码字  ──────→  可能翻转几个比特  ──────→  收到64位(可能有错)
                                                                    │
                                                                    ▼
                                                              Polar解码 → 尝试纠错
                                                                    │
                                                                    ▼
                                                              提取数据和CRC
                                                                    │
                                                                    ▼
                                                              重算CRC并对比
                                                                    │
                                                                    ▼
                                                              ┌─────────────┐
                                                              │ 两层都通过？  │
                                                              └──┬───────┬──┘
                                                                 是      否
                                                                 ▼       ▼
                                                             valid=1  valid=0
                                                             输出数据  拒绝指令
```

---

## 你需要做什么？（6 个任务）

你要用 SystemVerilog 写出上面流程中"发送端"和"接收端"的硬件模块，然后用仿真验证它们能正确工作。

### 任务依赖关系

```text
任务一（位置映射）──→ 任务二（CRC）──→ 任务三（编码器）──→ 任务四（解码器）──→ 任务五（测试）──→ 任务六（文档）
     基础参数           校验模块         发送端核心          接收端核心          验证            提交
```

---

## 任务一：位置映射（决定哪些格子放数据）

### 在做什么

64 位码字就像 64 个格子。你要决定哪 40 个格子放有用信息（信息位），哪 24 个格子永远填 0（冻结位）。这个选择决定了系统能纠正多少错误。

### 核心原理

每个格子位置对纠错能力的贡献不同。位置 i 的"保护力"取决于 i 的二进制中有多少个 1：

- 1 的个数越少 → 保护力越强
- 项目要求保护力 >= 8 → 只能选二进制中 1 的个数 <= 3 的位置

满足条件的有 42 个，但只需要 40 个，所以用 Bhattacharyya 参数排序，剔除最不可靠的 2 个（位置 0 和位置 1）。

### 产出

`polar_common_pkg.sv` 文件，包含 INFO_POS（40个）和 FROZEN_POS（24个）两个数组。后续所有模块都引用这个文件。

### 详细教程

参见 `任务一_位置映射详解.md`。

---

## 任务二：CRC-16 模块（给数据算校验码）

### 在做什么

对 24 位输入数据计算出 16 位校验码。类似身份证最后一位校验位——改动任何一位数据，校验码都会变。

### 核心原理

使用 CRC-16-CCITT 标准算法。想象一个 16 位的寄存器，数据从高位到低位一位一位地"推"进去，每推一位，寄存器做一次移位和条件异或操作。推完 24 位数据后，寄存器里的值就是 CRC。

### 伪代码

```text
crc = 0000000000000000  （16位全0）

对数据的每一位（从最高位到最低位）：
    feedback = 当前数据位 XOR crc的最高位
    crc 左移一位
    如果 feedback == 1：
        crc = crc XOR 0x1021

最终 crc 就是 16 位校验码
```

### 产出

一个 SystemVerilog 模块（可以独立成 `crc.sv`，也可以直接写在编码器/解码器内部），输入 24 位数据，输出 16 位 CRC。

---

## 任务三：Polar 编码器（发送端）

### 在做什么

把 24 位原始数据变成 64 位码字发送出去。这是发送端的核心。

### 工作流程

```text
输入：24位数据 data_in

第1步：算 CRC
  data_in → CRC模块 → 得到 16位 crc

第2步：组装 64 位向量 u
  创建一个 64 位全 0 的向量 u
  把 24 位数据放到 INFO_POS[0]~INFO_POS[23] 对应的格子里
  把 16 位 CRC 放到 INFO_POS[24]~INFO_POS[39] 对应的格子里
  冻结位的格子保持 0

第3步：蝶形变换（Polar 编码的核心操作）
  对 u 做 6 轮异或运算，每轮的间距不同（1, 2, 4, 8, 16, 32）
  这是纯数学运算，把信息"打散"到 64 位中
  输出就是 64 位码字 codeword

输出：64位 codeword + done脉冲
```

### 时序要求

`start` 信号拉高后，**恰好第 2 个时钟周期** `done` 拉高，同时 `codeword` 有效。

### 产出

`polar64_crc16_encoder.sv`

---

## 任务四：Polar 解码器（接收端）——最难的部分

### 在做什么

收到可能有错误的 64 位码字，尝试恢复出原始 24 位数据。如果错误太多无法恢复，就拒绝。

### 工作流程

```text
输入：64位接收码字 rx（可能有 0~若干位 被翻转）

第1步：逆 Polar 变换
  对 rx 做蝶形变换的逆操作，得到 u_hat
  如果没有错误，u_hat 的冻结位位置应该全是 0

第2步：检查冻结位（syndrome 检测）
  看 u_hat 的 24 个冻结位位置是否全为 0
  如果不全为 0 → 说明传输中有错误发生
  根据冻结位的"违规模式"（syndrome），判断错误有几位

第3步：尝试纠错
  如果 syndrome 对应的错误 <= 3 位 → 翻转对应的位来纠正
  如果错误 > 3 位 → 无法纠正，valid = 0

第4步：强制冻结位为 0
  不管之前怎样，把冻结位全部清零

第5步：提取数据和 CRC
  从 INFO_POS[0..23] 提取 24 位数据
  从 INFO_POS[24..39] 提取 16 位 CRC

第6步：CRC 校验（第二道防线）
  对提取出的数据重新算 CRC，与提取出的 CRC 对比
  一致 → valid = 1，输出数据
  不一致 → valid = 0，拒绝

输出：24位 data_out + valid + done脉冲
```

### 安全原则

**任何不确定的情况都输出 valid=0。** 错误地输出 valid=1（数据还是错的）会被重扣 20 分。

### 时序要求

`start` 后 **12 个时钟周期内** `done` 拉高。8 周期内完成可加 5 分。

### 产出

`polar64_crc16_decoder.sv`

---

## 任务五：验证测试

### 在做什么

写一个测试程序（testbench），自动测试编码器和解码器是否正确。

### 三个必测场景

| 场景 | 操作 | 期望结果 |
| --- | --- | --- |
| Case A：无错误 | 编码后直接解码 | valid=1，数据正确还原 |
| Case B：1~3位错误 | 编码后随机翻转1~3位再解码 | valid=1，数据正确还原 |
| Case C：4位错误 | 编码后翻转4位再解码 | valid=0（拒绝） |

### 测试流程

```text
1. 给编码器一个 data_in，得到 codeword
2. Case A：codeword 不改动，送入解码器 → 检查 valid=1 且 data_out == data_in
3. Case B：翻转 codeword 的 1~3 位，送入解码器 → 检查 valid=1 且 data_out == data_in
4. Case C：翻转 codeword 的 4 位，送入解码器 → 检查 valid=0
5. 用多组不同的 data_in 重复上述测试
```

### 产出

`tb_basic.sv`，用 Vivado xsim 运行通过。

---

## 任务六：写文档并提交

### 需要提交的文件

```text
team_XX_submission.zip
├── polar_common_pkg.sv          ← 任务一的产出（位置映射参数）
├── polar64_crc16_encoder.sv     ← 任务三的产出（编码器）
├── polar64_crc16_decoder.sv     ← 任务四的产出（解码器）
├── crc.sv                       ← 任务二的产出（可选，如已集成则不需要单独文件）
├── tb_basic.sv                  ← 任务五的产出（测试平台）
├── README.md                    ← 编译运行命令 + 模块说明 + 分工
├── report.pdf                   ← 最多2页报告
└── ai_log.txt                   ← AI使用日志
```

---

## 详细完成步骤

### 第一步：搞定位置映射（任务一）

1. 阅读 `任务一_位置映射详解.md`，理解原理
2. 运行其中的 Python 脚本，得到 INFO_POS 和 FROZEN_POS 的具体数值
3. 创建 `polar_common_pkg.sv`，把两个数组写进去
4. 验证：40 + 24 = 64，无重叠，所有信息位 popcount <= 3

### 第二步：实现 CRC-16（任务二）

1. 理解 CRC 算法：本质是对数据做 24 次移位 + 条件异或
2. 用 SystemVerilog 实现（推荐用组合逻辑 `always_comb`，用 for 循环展开 24 次迭代）
3. 用已知测试向量验证：可以用 Python 计算同一数据的 CRC 结果，对比硬件输出
4. 注意：处理顺序是 MSB 优先（从 `data_in[23]` 到 `data_in[0]`）

### 第三步：实现编码器（任务三）

1. 模块引用 `polar_common_pkg`
2. 内部逻辑分三块：
   - CRC 计算（复用任务二的逻辑）
   - u 向量组装（按 INFO_POS / FROZEN_POS 放置数据、CRC、0）
   - 蝶形变换（6 层嵌套 for 循环的异或操作，组合逻辑即可）
3. 时序控制：用一个简单的 2 拍计数器，start 后第 2 拍输出 done
4. 注意比特映射方向：`data_in[23-k]` 放到 `u[INFO_POS[k]]`（不是 `data_in[k]`）

### 第四步：实现解码器（任务四）

这是最复杂的部分，建议分步实现：

1. **逆 Polar 变换**：和编码的蝶形变换相同（Polar 码的一个特性：编码矩阵的逆 = 自身）
2. **Syndrome 计算**：检查逆变换后冻结位位置的值，非零说明有错
3. **纠错逻辑**：
   - 根据 syndrome 模式定位错误位
   - 如果错误位数 <= 3 → 翻转纠正
   - 如果错误位数 > 3 → 放弃，valid = 0
4. **数据提取**：从纠正后的 u_hat 中按 INFO_POS 提取数据和 CRC
5. **CRC 校验**：重新计算 CRC 并对比
6. 时序控制：确保 done 在 start 后 12 周期内拉高

### 第五步：编写测试平台（任务五）

1. 实例化编码器和解码器
2. 产生时钟和复位信号
3. 写测试序列：
   - 至少 3 组不同的 `data_in`
   - 每组测试 Case A（无错）、Case B（1~3位错）、Case C（4位错）
4. 用 `$display` 打印测试结果，自动对比期望值
5. 用 xsim 命令编译运行，确认全部通过

### 第六步：写文档并提交（任务六）

1. 写 README.md：编译命令、模块说明
2. 写 report.pdf（最多 2 页）：架构、验证策略、安全性反思
3. 整理 ai_log.txt
4. 打包提交

---

## 评分重点提醒

| 项目 | 分值 | 重点 |
| --- | --- | --- |
| CRC 正确性 | 15 | 多项式、初始值、比特顺序都不能错 |
| 编码器正确性 | 20 | 蝶形变换方向、比特映射方向 |
| 解码器无错信道 | 15 | 没有翻转时必须正确还原 |
| **安全行为** | **20** | **最高分项！错误的 valid=1 扣分最重** |
| 接口/时序 | 10 | 编码器恰好2周期，解码器12周期内 |
| 测试平台 | 10 | 三种场景全覆盖 |
| 代码+文档 | 10 | 可综合风格 + README + report |

**核心原则：宁可多输出 valid=0（漏报），也绝不输出错误的 valid=1（误报）。**
